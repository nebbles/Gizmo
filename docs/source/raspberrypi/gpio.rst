GPIO
====

The Raspberry Pi has General Purpose Input Output pins. This guide will give an short insight into controlling the GPIO pins on the Raspberry Pi using a Python library called **GPIOzero**.

1. `Materials needed`_
2. `GPIO pinout`_
3. `Analog vs. Digital`_
4. `Blink`_
5. `LED PWM`_
6. `Button`_
7. `Combining everything`_

Your Raspberry Pi is more than just a small computer, it is a hardware prototyping tool! The RPi has **bi-directional I/O pins**, which you can use to drive LEDs, spin motors, or read button presses. To drive the RPi's I/O lines requires a bit or programming. You can use a `variety of programing languages <http://elinux.org/RPi_GPIO_Code_Samples>`_, but we decided to use a really solid, easy language for driving I/O: **Python**.

Materials needed
----------------

* Raspberry Pi 3 B
* `Breadboard <https://www.sparkfun.com/products/12002?_ga=1.251311686.1915117394.1476705504>`_
* `Jumper Wires(M/F) <https://www.sparkfun.com/products/12794>`_
* `Momentary Pushbutton Switch <https://www.sparkfun.com/products/9190?_ga=1.213562324.1915117394.1476705504>`_
* `Resistors <https://www.sparkfun.com/products/11507?_ga=1.213562324.1915117394.1476705504>`_
* `2 LEDs <https://www.sparkfun.com/products/9590?_ga=1.213548756.1915117394.1476705504>`_

GPIO Pinout
-----------

Raspberry has its GPIO over a standard male header on the board. From the first models to the latest, the header has expanded from 26 pins to 40 pins while maintaining the original pinout.

.. image:: /_static/images/pi-gpio/rpi_old_new_pin.jpg
  :width: 500
  :align: center

There are (at least) two, different numbering schemes you may encounter when referencing **Pi pin numbers**:

1. **Broadcom (SoC) chip-specific** pin numbers.
2. **P1 physical** pin numbers.

You can use either number-system, but when you are programming how to use the pins, it requires that you declare which scheme you are using at the very beginning of your program. We will see this later.

The next table shows all 40 pins on the P1 header, including any particular function they may have, and their dual numbers:

.. image:: /_static/images/pi-gpio/header_pinout.jpg
  :width: 500
  :align: center

In the next table, we show another numbering system along with the ones we showed above: **Pi pin header numbers and element14 given names, wiringPi numbers, Python numbers, and related silkscreen on the wedge**. The Broadcom pin numbers in the table are related to RPi Model 2 and later only.

.. image:: /_static/images/pi-gpio/pi_pin_header_numbers.png
  :width: 500
  :align: center

This table shows that the RPi not only gives you access to the bi-directional I/O pins, but also

- `Serial (UART) <https://learn.sparkfun.com/tutorials/serial-communication>`_,
- `I2C <https://learn.sparkfun.com/tutorials/i2c>`_,
- `SPI <https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi>`_,
- and even some Pulse width modulation (`PWM <https://learn.sparkfun.com/tutorials/pulse-width-modulation>`_ — a.k.a. “analog output”).

.. tip::
  There is a useful online guide for finding the assignment and numbering of each pin, along with other guides, that you may find useful at: `pinout.xyz <pinout.xyz>`_

Analog vs. Digital
******************

Before starting with our practise, we will revise the difference between **analog** and **digital** signals. Both are used to transmit information, usually through **electric signals**. In both these technologies, the information, such as any audio or video, is transformed into electric signals. The **difference between analog and digital**:

- In **analog technology**, information is translated into electric pulses of varying amplitude.
- In **digital technology**, translation of information is into binary format (zero or one) where each bit is representative of two distinct amplitudes.

.. image:: /_static/images/pi-gpio/analog_digital.png
  :width: 500
  :align: center

Comparison chart
~~~~~~~~~~~~~~~~

.. raw:: html

  <div style="overflow-x:auto;font-size:.8em">
    <table border="1" cellpadding="5" style="width:100%;min-width:600px">
      <colgroup>
        <col span="1" style="width: 10%;">
        <col span="1" style="width: 20%;">
        <col span="1" style="width: 60%;">
      </colgroup>
      <tr bgcolor="#B0B1AF">
        <th></th>
        <th>Analogue</th>
        <th>Digital</th>
      </tr>
      <tr>
        <td >Signal</td>
        <td >Analog signal is a continuous signal which represents physical measurements.</td>
        <td >Digital signals are discrete time signals generated by digital modulation.</td>
      </tr>
      <tr>
        <td >Waves</td>
        <td >Denoted by sine waves.</td>
        <td >Denoted by square waves.</td>
      </tr>
      <tr>
        <td >Representation</td>
        <td >Uses continuous range of values to represent information.</td>
        <td >Uses discrete or discontinuous values to represent information.</td>
      </tr>
      <tr>
        <td >Example</td>
        <td >Human voice in air, analog electronic devices.</td>
        <td >Computers, CDs, DVDs, and other digital electronic devices.</td>
      </tr>
      <tr>
        <td >Technology</td>
        <td >Analog technology records waveforms as they are.</td>
        <td >Samples analog waveforms into a limited set of numbers and records them.</td>
      </tr>
      <tr>
        <td >Data transmissions</td>
        <td >Subjected to deterioration by noise during transmission and write/read cycle.</td>
        <td >Can be noise-immune without deterioration during transmission and write/read cycle.</td>
      </tr>
      <tr>
        <td >Response to Noise</td>
        <td >More likely to get affected reducing accuracy.</td>
        <td >Less affected since noise response are analog in nature.</td>
      </tr>
      <tr>
        <td >Flexibility</td>
        <td >Analog hardware is not flexible.</td>
        <td >Digital hardware is flexible in implementation.</td>
      </tr>
      <tr>
        <td >Uses</td>
        <td >Can be used in analog devices only. Best suited for audio and video transmission.</td>
        <td >Best suited for Computing and digital electronics.</td>
      </tr>
      <tr>
        <td >Applications</td>
        <td >Thermometer.</td>
        <td >PCs, PDAs.</td>
      </tr>
      <tr>
        <td >Bandwidth</td>
        <td >Analog signal processing can be done in real time and consumes less bandwidth.</td>
        <td >There is no guarantee that digital signal processing can be done in real time and consumes more bandwidth to carry out the same information.</td>
      </tr>
      <tr>
        <td >Memory</td>
        <td >Stored in the form of wave signal.</td>
        <td >Stored in the form of binary bit.</td>
      </tr>
      <tr>
        <td >Power</td>
        <td >Analog instrument draws large power.</td>
        <td >Digital instrument draws negligible power.</td>
      </tr>
      <tr>
        <td >Cost</td>
        <td >Low cost and portable.</td>
        <td >Cost is high and not easily portable.</td>
      </tr>
      <tr>
        <td >Impedance</td>
        <td >Low</td>
        <td >High order of 100 megaohms</td>
      </tr>
      <tr>
        <td >Errors</td>
        <td >Analog instruments usually have a scale which is cramped at lower end and give considerable observational errors.</td>
        <td >Digital instruments are free from observational errors like parallax and approximation errors.</td>
      </tr>
    </table>
  </div>
 <br>



Blink
-----

We will start with a very easy example, the classic "Blink" example, later we will do the same with our Arduino and see the differences.

Hardware Setup
**************

We start assembling the circuit as shown in the diagram below.

.. image:: /_static/images/pi-gpio/raspi-blink-wiring.png
  :width: 500
  :align: center

The Code
********

For the code we are going to use the `GPIOzero <https://gpiozero.readthedocs.io/en/stable/>`_ library which is based on the `standard GPIO library <https://sourceforge.net/p/raspberry-gpio-python/wiki/Home/>`_.

1. From your laptop's terminal connect to the RPi
2. Create a folder called "code" and inside it a file called "blinker.py":

.. code-block:: bash

  $ mkdir code
  $ cd code
  $ nano blinker.py

.. note:: You may not need to create a new folder every time for the script. i.e. once you have created the folder code, you can create the scripts within the folder with ``nano <script name>``. The command ``nano`` in this case is to open the nano editor.

3. Copy and paste this code:

.. code-block:: python

  #!/usr/bin/env python

  from gpiozero import LED
  from time import sleep

  led = LED(17)

  while True:
      led.on()
      sleep(1)
      led.off()
      sleep(1)


4. Save and exit
5. Run this script with the command:

.. code-block:: bash

  sudo python ./blinker.py

6. To stop the script from running press ``CTRL+C``
7. To make the script an executable run:

.. code-block:: bash

  $ sudo chmod u+x blinker.py

Now you can execute it with just this command:

.. code-block:: bash

  $ ./blinker.py

8. Yay! The LED is blinking!

Understanding the "Blink" example
*********************************

.. code-block:: python

  #!/usr/bin/env python

This line is used to tell which interpreter (in our case Python) to use when the file is made into an executable.

When we use Python to control our GPIO pins, we always need to import the corresponding Python module, which goes at the top of the script:

.. code-block:: python

  import gpiozero as gpio

Here, we are giving a shorter name to the module “GPIOzero”, in order to call the module through our script. This line is fundamental for every script requiring GPIO functions. If you want to import only certain classes from "GPIOzero" you could also specify the components. As an example, let's say if you are interested in only the LED:

.. code-block:: python

  from gpiozero import LED

Or if want to use the Button and LED class.

.. code-block:: python

  from gpiozero import LED, Button

And if we are just importing the function sleep from the `time library <https://www.tutorialspoint.com/python/time_sleep.htm>`_, we will later use it to make the LED blink.

.. code-block:: python

  from time import sleep

In the next line:

.. code-block:: python

  led = LED(17)

Here we are creating a variable called ``led`` and we are initialising it with an object of the class `LED <https://gpiozero.readthedocs.io/en/stable/api_output.html#led>`_. On object of the class LED to be initialised takes as a parameter the pin number to which the LED is connected to, in our case the pin number is 17 (BCM 17, not physical pin number 17).

.. note::
  GPIOzero uses **ONLY** Broadcom (BCM) pin numbering, instead of physical pin numbering and it is not configurable, so when referring to pins in one of your scripts always use this numbering:

.. image:: /_static/images/pi-gpio/broadcom_pin_layout.svg
  :width: 250
  :align: center


.. code-block:: python

  while True:

Here we are are basically asking to Python to loop forever. In fact the ``while`` statements loops through its code until the initial condition becomes false, in our case never.

.. code-block:: python

  led.on()
  sleep(1)
  led.off()
  sleep(1)

Here we are using two methods of the class `LED <https://gpiozero.readthedocs.io/en/stable/api_output.html#led>`_ of GPIOzero. ``on()`` switches the device on and ``off()`` turns it off. We are calling the two functions with a 1 second interval, in fact the function ``sleep()`` suspends execution for the given number of seconds.

LED PWM
-------

Use the same layout for the electronics as before.

What is PWM?
************

Pulse Width Modulation, or PWM, is a technique for getting analog results with digital means. Digital control is used to create a square wave, a signal switched between on and off. This on-off pattern can simulate voltages in between full on (3.3 Volts for RPi and 5 Volts for Arduino) and off (0 Volts) by changing the portion of the time the signal spends on versus the time that the signal spends off. The duration of "on time" is called the pulse width. To get varying analog values, you change, or modulate, that pulse width. If you repeat this on-off pattern fast enough with an LED for example, the result is as if the signal is a steady voltage between 0 and 5v controlling the brightness of the LED.

.. hint::
  For more information check out `this link <https://learn.sparkfun.com/tutorials/pulse-width-modulation>`_.

The Code
********

Repeat the same steps of "Blink" to upload the code below, this time call the file *led-pwm.py* and save it in the ``code`` folder that we have previously created. It's up to you to make the code executable or not.

.. code-block:: python

  #!/usr/bin/env python

  from gpiozero import PWMLED
  from time import sleep

  led = PWMLED(17)

  while True:
      led.value = 0  # off
      sleep(1)
      led.value = 0.5  # half brightness
      sleep(1)
      led.value = 1  # full brightness
      sleep(1)


Understanding "LED PWM" code
****************************

The main difference here is that we are using the `class PWMLED <https://gpiozero.readthedocs.io/en/stable/api_output.html#gpiozero.PWMLED>`_ instead of the class LED. The PWMLED class has an extra parameter that we can tweak which is ``value``. ``value`` indicates the duty cycle of this PWM device. ``0.0`` is off, ``1.0`` is fully on. Values in between may be specified for varying levels of power in the device.

Button
------

Hardware Setup
**************

We start assembling the circuit as shown in the diagram below.

.. image:: /_static/images/pi-gpio/button-wiring.png
  :width: 500
  :align: center

The Code
********

Repeat the same steps of "Blink" to upload the code below, this time call the file *button.py* and save it in the ``code`` folder that we have previously created. It's up to you to make the code executable or not.

.. code-block:: python

  #!/usr/bin/env python

  from gpiozero import Button

  button = Button(2)  # we first create an instance of the Button class
  buttonWasPressed = False # 1st flag will help us track if the button was pressed in the last loop
  buttonWasReleased = False # 2nd flag will help us track if the button was released in the last loop

  while True:
      
      if button.is_pressed:
          buttonWasReleased = False  # reset back to false since the button is now being pressed
          
          # we only want the print() code to be run once, 
          # so if it was pressed the last time the code looped, don't print it this time!
          if not buttonWasPressed:
              print("Button is pressed")

              # since we have now run this code, we don't want
              # it to run the next time the code loops, so
              buttonWasPressed = True 
      
      else:
          # this code is run when the button is not being pressed
          buttonWasPressed = False
          if not buttonWasReleased:
              print("Button is released")
              buttonWasReleased = True


Understanding "Button" code
***************************

Here we are using the `class Button <https://gpiozero.readthedocs.io/en/stable/api_input.html#button>`_ from ``GPIOzero``. This class has many functions and parameter, so make sure you check out the reference. Here we are using the ``is_pressed`` property of the class. ``is_pressed`` returns True if the device is currently active and False otherwise.

In this example, we also introduce the concept of flags. Flags are a way to help us keep track of the binary state of a particular thing by storing them as boolean variables (``1``/``0`` or ``True``/``False``). In this case, we need to keep track of the binary state of whether the button is was pressed, and the binary state of whether the button was released.

.. note::
  We need to keep track of the *actions* that occurred, not the state of the button itself as this is already monitored ``is_pressed`` property of the ``Button()`` class.

In the code above, we use these flags to prevent the repetition of a print statement. i.e. If we did not have them, then the *"Button is released"* statement would print repetitively until the button was pressed, and vice versa.

Flags allow us to ensure the print statement is only *printed* on the first iteration of the loop. Every iteration thereafter will skip the print statement. This occurs until there is a change in the ``is_pressed`` property, at which point the respective flag is reset to ``False``.


Combining Everything
--------------------

Now we challenge you to combine all the previous three scripts to create one. Make the script in order that:

- when the button is pressed one of the two LEDs fades to 25% of its brightness and the other one blinks once
- when the button is released the PWM LED goes back to 100% brightness.

Hardware Setup
**************

We start assembling the circuit as shown in the diagram below.

.. image:: /_static/images/pi-gpio//practise_1.png
  :width: 500
  :align: center

Code Tips
*********

Use the ``when_pressed`` and ``when_released`` properties of the `Button class <https://gpiozero.readthedocs.io/en/stable/api_input.html#button>`_. You can find the code to control one LED with the button, `here <https://gpiozero.readthedocs.io/en/stable/recipes.html#button-controlled-led>`_.

.. admonition:: Acknowledgements
   :class: refbox

   - Based on the GPIOzero library `notes <https://gpiozero.readthedocs.io/en/stable/index.html>`_,
   - `this reference <http://www.diffen.com/difference/Analog_vs_Digital>`_,
   - and `this Sparkfun intro <https://learn.sparkfun.com/tutorials/raspberry-gpio>`_.
